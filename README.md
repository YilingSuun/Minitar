# Introduction

The goal of this program is to develop a simplified version of the `tar` utility, called `minitar`. `tar` is one of the popular tools among users of Linux and other Unix-derived operating systems. It creates a single archive file from several member files. Thus, `tar` is very similar to the zip tool we use, although it does not perform file compression as `zip` does.

The `tar` utility was originally developed back in the era of widespread archival storage on magnetic tapes – `tar` is in fact short for “tape archive.” Therefore, archive files created by `tar` have a very simple format that is easy to read and write sequentially. While this program do not replicate the full functionality of the original `tar` utility, it will still be quite capable. It will allow you to create to create archives from files, modify existing archives, and extract the original files back from an archive.

minitar is fully Posix-compliant, meaning it can freely interoperate with all of the standard tape-archive utility programs like the original `tar`. In other words, `minitar` will be able to read and manipulate archives generated by `tar`, and vice versa. 

Note, however, that there are some areas in which Linux’s `tar` program differs from strict adherence to the Posix standard – meaning the archives produced by `minitar` won’t always be byte-for-byte equivalent with those of tar.

---

# minitar

The `tar` program included in most Unix-based environments, like Linux in our 4061 Docker containers, 
has become known for its complicated command-line syntax. We will use a simplified version of the 
Unix-style command line arguments from the original `tar` for our `minitar` program (as opposed to 
the “Traditional” or GNU style arguments you may run across in other examples and documentation).

---

## Usage

Any command-line invocation of `minitar` will adhere to the following pattern:

```
./minitar <operation> -f <archive_name> <file_name_1> <file_name_2> ... <file_name_n>
```

### Operations

- **`-c` : Create**  
  Create a new archive file with the name `<archive_name>` and including all member files identified 
  by each `<file_name_i>` command-line argument.
  
  **Example Command:**
  ```
  ./minitar -c -f foo.tar hello.txt hola.txt
  ```
  
- **`-a` : Append**  
  Append more member files identified by each `<file_name_i>` argument to the existing archive file 
  identified by `<archive_name>`.
  
  **Example Command:**
  ```
  ./minitar -a -f foo.tar goodbye.txt adios.txt
  ```

- **`-t` : List**  
  List out (print to the terminal) the name of each member file included in the archive identified 
  by `<archive_name>`.  
  (No `<file_name_i>` arguments are necessary).
    
  **Example Command:**
  ```
  ./minitar -t -f foo.tar
  ```

- **`-u` : Update**  
  Update all member files identified by the `<file_name_i>` arguments contained in the archive file 
  identified by `<archive_name>`.  
  The archive must already contain all of these files, and new versions of each file will be appended 
  to the end of the archive.
  
 **Example Command:**
  ```
  ./minitar -u -f foo.tar goodbye.txt adios.txt
  ```

- **`-x` : Extract**  
  Extract all member files from the archive identified by the `<archive_name>` argument and save them 
  as regular files in the current working directory.  
  (No `<file_name_i>` arguments are necessary).

  **Example Command:**
  ```
  ./minitar -x -f foo.tar
  ```


# Makefile

A `Makefile` is provided as part of this project, much like you have seen for the lab assignments. This file supports the following commands:

`make`: Compile all code, produce an executable `minitar` program.
`make clean`: Remove all compiled items. Useful if you want to recompile everything from scratch.
`make clean-tests`: Remove all files produced during execution of the tests.
`make zip`: Create a zip file for submission to Gradescope
`make test`: Run all test cases
`make test` testnum=5: Run test case #5 only

